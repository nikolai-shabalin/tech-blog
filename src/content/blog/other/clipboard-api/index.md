---
title: "Clipboard API: как работать с буфером обмена"
description: "Clipboard API позволяет работать с буфером обмена браузера. В этой статье мы рассмотрим основные возможности API и как их использовать в проектах."
pubDate: "July 03 2025"
---

## Введение

Современные веб‑приложения перестали быть пассивными витринами контента — сегодня они активно обмениваются данными с пользовательской средой, стремясь обеспечить столь же плавный опыт, как и нативные программы. Одним из элементов этого взаимодействия является буфер обмена (clipboard), служащий универсальным каналом передачи текста, изображений и других форматов данных между приложениями и устройствами.

**Clipboard API** — [это стандарт](https://www.w3.org/TR/clipboard-apis/), определяющий, как веб‑страница может перехватывать операции копирования(`Ctrl + C`), вырезания(`Ctrl + X`) и вставки(`Ctrl + V`), а также непосредственно читать и записывать данные в системный буфер обмена.

Стандарт логически разделён на две взаимодополняющие части:

1. **Clipboard Events** — событийная модель (`copy`, `cut`, `paste`), позволяющая отслеживать действия пользователя и модифицировать содержимое буфера «на лету». Этот подход хорошо знаком разработчикам, привыкшим работать с DOM‑событиями.
    ```js
    // Перехват копирования текста
    document.addEventListener('copy', (e) => {
        // Отменяем стандартное поведение
        e.preventDefault();
        // Записываем текст в буфер обмена
        const text = 'Hello, world!';
        e.clipboardData.setData('text/plain', text);
    });
    ```
2. **Async Clipboard API** — асинхронный, промис‑ориентированный интерфейс (`navigator.clipboard`), открывающий прямой программный доступ к операциям чтения и записи. Он избавляет от необходимости симулировать пользовательские жесты, но требует соблюдения более строгих политик безопасности и работает только из доверенного контекста (Secure Context).
    ```js
    // Чтение текста из буфера обмена
    navigator.clipboard.readText().then(text => {
        console.log('Текст из буфера обмена:', text);
    });
    ```


Мы рассмотрим, как оба компонента API помогают создавать удобные, безопасные и доступные решения при работе с буфером обмена, а также обсудим ограничения и лучшие практики их применения.


## 1. Clipboard Events (События буфера обмена)
### 1.1 Что такое Clipboard Events?

`Clipboard Events` — это [часть DOM‑спецификации](https://www.w3.org/TR/clipboard-apis/#clipboard-event-definitions), предоставляющая браузеру набор событий, срабатывающих при взаимодействии пользователя с буфером обмена. Разработчик получает контроль над содержимым и форматом данных ещё до того, как они покинут браузер или попадут в документ.

**Ключевые события**

* **`copy`** — инициируется, когда пользователь копирует выбранные данные.
* **`cut`** — срабатывает при вырезании данных.
* **`paste`** — возникает при попытке вставить содержимое буфера в документ.
* **`clipboardchange`** — (экспериментальное) уведомляет о факте изменения буфера обмена в системе.

#### Сценарии использования

Ниже приведены типичные примеры задач, где каждое событие оказывается незаменимым (в скобках указано, какое событие используется):

* Автоматическое добавление ссылки‑источника при копировании цитаты (**copy**).
* Встраивание авторских метаданных при копировании фрагмента кода (**copy**).
* Очистка форматирования из Word перед вставкой в текстовый редактор (**paste**).
* Блокировка вставки изображений в поле, принимающее только текст (**paste**).
* Выделение объекта и одновременное сохранение его в историю «Undo» при вырезании (**cut**).
* Мгновенное уведомление «Скопировано!» после успешного действия (**copy**).
* Разрешение вставки только определённых MIME‑типов (например, `image/png`) в форму загрузки (**paste**).
* Синхронизация буфера обмена между вкладками PWA для совместного редактирования (**clipboardchange**).
* Захват свежего скриншота при его появлении в системном буфере и вставка в комментарий (**clipboardchange**).
* Восстановление случайно вырезанных элементов через внутреннюю буферизацию (**cut**).


### 1.2 Работа с событием копирования (`copy`)
Событие `copy` срабатывает в момент, когда пользователь инициирует копирование данных (горячие клавиши, контекстное меню или вызов `document.execCommand('copy')`). На этой стадии скрипт ещё может изменить содержимое, которое реально попадёт в системный буфер обмена.

#### Ключевые особенности

1. **Полный контроль над данными** — вызвав `event.preventDefault()` и использовав `event.clipboardData.setData()`, можно записать в буфер любой поддерживаемый MIME-тип текста.
2. **Только по пользовательскому жесту** — браузер позволит сгенерировать `copy` лишь в ответ на явное действие, что защищает от скрытого копирования.
3. **Безопасность происхождения** — скрипт не может читать содержимое, скопированное на другом сайте (same-origin policy).
4. **Широкая поддержка** — все современные браузеры реализуют базовый функционал для текстовых форматов.


#### Практический пример №1

**Автоматическое добавление ссылки на источник при копировании цитаты**

```html
<article class="quote" id="quote">
  <p class="quote__text">«В программировании нет серебряной пули.» — Фредерик Брукс</p>
</article>
```

```js
// Глобальный обработчик: перехватываем копирование в документе
const quoteElement = document.querySelector('.quote');

// Обработчик события копирования
quoteElement.addEventListener('copy', (event) => {
  // Получаем выделение пользователя
  const selection = document.getSelection();
  // Если нет выделения, то ничего не делаем
  if (!selection) return;

  // Формируем текст и подпись-источник
  const pageUrl = document.location.href;
  const text = `${selection.toString()}\n\nИсточник: ${pageUrl}`;

  // Подменяем содержимое буфера обмена
  event.preventDefault();
  event.clipboardData.setData('text/plain', text);
});
```

**Зачем это нужно?**
Такой приём часто применяют блоги, новостные сайты и техническая документация, чтобы каждая цитата, скопированная пользователем, автоматически содержала ссылку на исходную страницу. Это повышает шансы получить корректный атрибут источника при дальнейшем распространении текста.

#### Идеи для дальнейшего развития

* Генерировать преформатированный Markdown-блок вместо обычного текста.
* Вставлять UTM-метку в ссылку, чтобы отслеживать копипастный трафик.
* Для кода — добавлять команду «npm install …» или имя файла, откуда взят фрагмент.

> Используйте событие `copy` осознанно: не превращайте его в ненужный шум для пользователя и всегда оставляйте возможность скопировать «чистый» текст без приставок — например, через кнопку «Copy plain».

### 1.3 Работа с событием вырезания (`cut`)
`cut` — это близкий родственник события `copy`, но с одной принципиальной разницей: после вызова пользователь ожидает, что выделенный фрагмент будет удалён из исходного контекста. Перехватывая это событие, скрипт может:

1. **Придать действию предсказуемость** — самостоятельно решить, какие данные попадут в буфер, а какие останутся в документе.
2. **Управлять форматированием** — сохранять в буфере «чистый» текст, а в документе удалять ещё и обёртки-разметку.
3. **Синхронизировать состояние** — например, обновлять историю изменений (Undo/Redo) или отправлять событие на сервер для коллаборативного редактирования.
4. **Защищать данные** — блокировать вырезание конфиденциальных частей интерфейса (пароли, токены), подменяя содержимое буфера бессмысленным плейсхолдером.


#### Практический пример №2

**Полный контроль «Вырезать»: вручную удаляем текст после помещения в буфер**

```js
// Глобальный обработчик: перехватываем вырезание в документе
document.addEventListener('cut', (event) => {
  // Читаем выделение пользователя
  const selection = document.getSelection();
  if (!selection || selection.isCollapsed) return;

  // Формируем собственное содержимое буфера
  const selectedText = selection.toString();
  event.clipboardData.setData('text/plain', selectedText);

  // Отменяем стандартное поведение
  event.preventDefault();

  // Удаляем выделенный текст вручную (сохраняя Undo-историю)
  // Функция действует в зависимости от контекста: textarea, contentEditable, и т.д.
  deleteSelectedText(selection);
});

// Пример простой функции удаления для contentEditable/textarea
function deleteSelectedText(sel) {
  // Если нет выделения, то ничего не делаем
  if (sel.rangeCount === 0) return;
  // Получаем первый диапазон выделения
  const range = sel.getRangeAt(0);
  // Удаляем содержимое диапазона
  range.deleteContents();
  sel.removeAllRanges();
}
```

**Что происходит:**

1. Пользователь нажимает `Ctrl+X` или выбирает «Вырезать».
2. Срабатывает обработчик `cut`.
3. Скрипт помещает в буфер *только то*, что считает нужным (`selectedText`).
4. Стандартное поведение отключено, поэтому браузер *не* удаляет текст сам.
5. Функция `deleteSelectedText` аккуратно удаляет выделение — это можно сделать по-разному для разных типов полей и при необходимости записать действие в историю «Undo».

#### Где это бывает полезно

* **Кодовые песочницы**: при вырезании фрагмента кода одновременно очищается привязанный breakpoint (**cut**).
* **WYSIWYG-редакторы**: удаление форматирования, не влияя на скрытые служебные теги (**cut**).
* **Безопасные поля**: превращение вырезанного пароля в строку `******`, чтобы данные не покидали сайт (**cut**).
* **Коллаборативные приложения**: синхронная отправка «пачки» изменений на сервер после вырезания элемента (**cut**).

> Используйте `cut` ответственно: если вы перехватываете событие, обеспечьте корректное удаление данных и сохраните привычную для пользователя модель поведения.


### 1.4 Работа с событием вставки (`paste`)
Событие `paste` срабатывает, когда пользователь пытается вставить содержимое буфера обмена. В этот момент скрипт может:

1. **Прочитать данные** из буфера с помощью `event.clipboardData.getData()` (для поддерживаемых MIME-типов — чаще всего `text/plain`, реже `text/html`, `image/png` и т. д.).
2. **Преобразовать или фильтровать** их до вставки — например, убрать нежелательные стили, добавить подпись, заменить запрещённые символы.
3. **Полностью перехватить процесс вставки**, вызвав `event.preventDefault()` и вставив данные вручную (удобно для контент-editable областей, кастомных редакторов, чатов).
4. **Повысить безопасность** — блокировать вставку опасного HTML, скриптов, скрытых элементов.


#### Практический пример №3

**Автоматическое добавление префикса к вставляемому тексту**

```html
<textarea class="clipboard__input" id="clipboard-input"></textarea>
<div class="clipboard__editable" id="clipboard-editable" contenteditable="true"></div>
```

```js
// Глобальный обработчик для всей страницы
document.addEventListener('paste', (event) => {
  // Читаем текст из буфера
  const pastedText = event.clipboardData.getData('text/plain');
  if (!pastedText) return;

  // Модифицируем содержимое
  const modifiedText = `Скопировано: ${pastedText}`;

  // Вставляем в текущую позицию курсора (ваша функция)
  insertTextAtCursor(modifiedText);

  // Запрещаем браузеру выполнять стандартную вставку
  event.preventDefault();
});

/**
 * Простая утилита для вставки текста в позицию курсора
 * Подходит для <textarea>, <input> и contentEditable-элементов.
 */
function insertTextAtCursor(text) {
  // Получаем текущий активный элемент
  const active = document.activeElement;

  // Вариант для .clipboard__input (textarea/input)
  if (active && active.classList.contains('clipboard__input')) {
    const start = active.selectionStart;
    // Получаем текущую позицию курсора
    const end   = active.selectionEnd;
    // Получаем текущее значение элемента
    const value = active.value;
    active.value = value.slice(0, start) + text + value.slice(end);
    // Ставим курсор после вставленного текста
    active.selectionStart = active.selectionEnd = start + text.length;
    return;
  }

  // Вариант для contentEditable
  if (active && active.isContentEditable) {
    document.execCommand('insertText', false, text);
  }
}
```

**Что здесь происходит**

1. Пользователь нажимает `Ctrl + V` или выбирает «Вставить».
2. Скрипт считывает чистый текст из буфера.
3. Добавляет к нему префикс **«Скопировано: »**.
4. Вставляет изменённую строку в позицию курсора.
5. Браузер больше ничего не делает, потому что мы вызвали `preventDefault()`.

#### Где это применяют на практике

* **Чаты и мессенджеры**: автоматическое добавление временной отметки или метки «Цитата» перед вставляемым сообщением (**paste**).
* **CMS и WYSIWYG-редакторы**: очистка форматирования Word/Pages, подмена нестандартных кавычек, удаление опасных тегов (**paste**).

> При перехвате `paste` не забывайте об уважении к ожиданиям пользователя: всегда оставляйте способ вставить «несанитизированный» текст (например, через горячие клавиши `Ctrl + Shift + V` или отдельную кнопку «Вставить как есть»).


## 2. Async Clipboard API (Асинхронный Clipboard API)
`Async Clipboard API` предоставляет промис-ориентированный доступ к системному буферу обмена через объект `navigator.clipboard` (`writeText()`, `readText()`, `write()`, `read()`). В отличие от устаревшей пары `document.execCommand('copy'/'paste')`, новый интерфейс:

* **Асинхронен по умолчанию** — все операции возвращают `Promise`, что предотвращает «заморозку» UI-потока и обеспечивает совместимость с await-синтаксисом.
* **Не привязан к DOM-событию** — разработчик может выполнять копирование по щелчку кнопки или в ответ на любой доверенный жест, без хака с временным созданием `textarea` и выделением текста.
* **Защищён политиками браузера** — чтение или запись требуют явно доверенного контекста (HTTPS или `localhost`) и соблюдения разрешений (см. ниже).
* **Поддерживает двоичные данные** (через `ClipboardItem`), что открывает путь к передаче изображений, файлов и собственных MIME-типов.

Причины появления асинхронного API:

1. **Производительность** — синхронные clipboard-вызовы блокировали основной поток, вызывая фризы на слабых устройствах.
2. **Безопасность** — браузеру нужно время, чтобы запросить разрешение у пользователя или проверить политику происхождения.
3. **Унификация** — единый объект `navigator.clipboard` упрощает работу для разработчиков и устраняет различия между платформами.

### 2.1 Разрешения доступа (Permissions API)

Перед непосредственным чтением/записью браузер проверяет **право** веб-страницы на операцию. Разрешения управляются через `Permissions API` и два ключевых имени:

| Разрешение        | Описание                                                                            | Типичные сценарии                                                         |
| ----------------- | ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| `clipboard-read`  | Позволяет считывать данные из системного буфера обмена без участия события `paste`. | Просмотр содержимого буфера перед вставкой, генерация превью изображений. |
| `clipboard-write` | Позволяет добавлять данные в буфер (при соблюдении пользовательского жеста).        | Кнопка «Copy», экспорт таблицы в CSV, генерация QR-кода в PNG.            |

Запрос статуса:

```js
const status = await navigator.permissions.query({ name: 'clipboard-read' });
console.log(status.state); // 'granted' | 'prompt' | 'denied'
```

> **Важно:** даже при `granted` браузер может потребовать явного пользовательского жеста для защиты от скрытого копирования.

### 2.2 Чтение текста из буфера обмена
Метод `navigator.clipboard.readText()` позволяет получить строковые данные прямо из системного буфера обмена, минуя событие `paste`.  Вызов возвращает `Promise`, благодаря чему операция не блокирует UI-поток и легко сочетается с `async / await`.

> **Важно:** если страница запущена по HTTP или вне пользовательского жеста, произойдёт исключение `NotAllowedError`.

#### Проверка разрешения

Перед чтением можно запросить статус через Permissions API:

```js
const { state } = await navigator.permissions.query({ name: 'clipboard-read' });
if (state === 'denied') {
  console.warn('Доступ к буферу отклонён пользователем.');
}
```

#### Практический пример №4: Чтение текста по кнопке

```html
<button class="clipboard__action clipboard__action_type_read">Прочитать из буфера</button>
```

```js
async function readClipboard() {
  try {
    // 1. Получаем текст
    const text = await navigator.clipboard.readText();

    // 2. Выводим результат (можно вставить в textarea.)
    console.log('Текст из буфера:', text);
  } catch (err) {
    // Наиболее частые причины: отсутствие жеста, протокол http, denied permission
    console.error('Ошибка чтения:', err);
  }
}

// 3. Привязываем функцию к нажатию кнопки (пользовательский жест обязателен)
document.querySelector('.clipboard__action_type_read').addEventListener('click', readClipboard);
```

**Как работает сценарий**

1. Пользователь кликает по кнопке — это считается доверенным жестом.
2. Браузер проверяет разрешение `clipboard-read`.
   * Если статус **prompt** — появляется диалог; при **granted** запрос пропускается.
3. Метод `readText()` асинхронно возвращает содержимое буфера.
4. Скрипт отображает текст или использует его дальше (автозаполнение формы, анализ и т.д.).

#### Идеи для практического применения

* **Автозаполнение** купона: считайте промокод, если пользователь скопировал его на другом сайте (**readText**).
* **Быстрый импорт настроек**: по клику считайте JSON-строку, проверьте формат и примените конфигурацию приложения (**readText**).

### 2.3 Что такое `ClipboardItem` и зачем он нужен

`ClipboardItem` — это оболочка, позволяющая упаковать произвольный двоичный или текстовый ресурс (Blob, File, строку) вместе с его **MIME-типом** и передать в системный буфер обмена. В отличие от методов `writeText()` / `readText()`, которые ограничены plain-text строками, `ClipboardItem` открывает доступ к работе с:
* изображениями (`image/png`, `image/jpeg`, `image/svg+xml`);
* документами (`application/pdf`, `text/markdown`);
* аудио и видео-фрагментами (при поддержке браузера);
* пользовательскими форматами («application/x-my-custom-data»).

Таким образом, Async Clipboard API превращается в полноценный механизм обмена любыми данными между веб-приложением и внешними программами.

#### Ключевые особенности

| Особенность                       | Детали                                                                                                                                |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| **Поддержка нескольких форматов** | Один `ClipboardItem` может содержать сразу несколько представлений: например, `image/png` и «fallback» `text/plain`.                  |
| **Асинхронная сериализация**      | Blob-объект читается лениво; браузер запрашивает данные только при фактическом обращении к буферу.                                    |
| **Права доступа**                 | Для записи требуется разрешение `clipboard-write`, а для чтения — `clipboard-read`; обе операции выполняются только в Secure Context. |
| **Ограничения платформы**         | На iOS и некоторых версиях Android поддерживаются лишь текстовые типы; проверяйте `navigator.clipboard.write` на наличие.             |

#### Как копировать изображения и другие форматы

1. **Получите Blob** изображения — через `fetch()`, `<canvas>.toBlob()`, `File` из `<input type="file">` или Web Share API.
2. Создайте `ClipboardItem`, передав объект `{ [mimeType]: blob }`.
3. Вызовите `navigator.clipboard.write([item])` внутри обработчика пользовательского жеста (клик, клавиша).

> **Совет:** добавляйте альтернативный `text/plain`, чтобы при вставке в неизображённый редактор пользователь получил хотя бы URL или подпись.

#### Практический пример №5: Копирование изображения в буфер обмена

```html
<button class="clipboard__action clipboard__action_type_copy-image">Скопировать изображение</button>
```

```js
async function copyImage() {
  // 1. Загружаем файл (можно взять любую картинку вашего сайта)
  const response = await fetch('/image.png');
  const blob     = await response.blob(); // Blob с MIME image/png

  // 2. Создаём ClipboardItem
  const item = new ClipboardItem({ 'image/png': blob });

  // 3. Пишем в буфер обмена
  try {
    await navigator.clipboard.write([item]);
  } catch (err) {
    console.error('Ошибка копирования:', err);
  }
}

// Пример вызова из кнопки
document.querySelector('.clipboard__action_type_copy-image').addEventListener('click', copyImage);
```


#### Что ещё можно делать с `ClipboardItem`

| Сценарий                                  | Формат                           | Польза                                                                        |
| ----------------------------------------- | -------------------------------- | ----------------------------------------------------------------------------- |
| **Копирование QR-кода** из canvas         | `image/png` + `text/plain` (URL) | Пользователь вставит картинку в чат, а в текстовом редакторе — просто ссылку. |
| **Экспорт отрывка таблицы** как CSV       | `text/csv` + `text/plain`        | В Excel откроется структура, в Notepad — «сырой» текст.                       |
| **Передача диаграмм** из онлайн-редактора | `image/svg+xml` + `text/html`    | Вектор вставится в Figma как SVG, в Word — как HTML-фрагмент.                 |
| **Снимок аудиоредактора**                 | `audio/wav` + `text/plain`       | DAW примет WAV, а в мессенджер уедет подпись «Audio clip».                    |

> На практике всегда проверяйте поддержку интересующего MIME-типа и предлагайте fallback-вариант: не все программы умеют «понимать» кастомные форматы, а пользователю важно получить хоть что-то вставляемое.

## Источники
- [Clipboard API and events](https://www.w3.org/TR/clipboard-apis/)
